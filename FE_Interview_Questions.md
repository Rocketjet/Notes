# FE_Interview_Questions

## RxJs

1. **У чому різниця між Hot та Cold Observables? Які сценарії найкраще підходять для використання кожного з них?**
   - Різниця між **Hot** та **Cold** _Observables_ пов'язана з моментом створення та початку випромінювання подій.
   - **Cold** _Observables_:
     - Починає випускати елементи лише при підписці на нього
     - Кожен передплатник отримує свій власний потік подій і починає його отримувати від початку
   - **Hot** _Observables_:
     - Починає випускати події незалежно від того, чи підписані на нього передплатники чи ні
     - Усі передплатники отримують один і той же потік подій, починаючи з поточного моменту, незалежно від того, коли вони передплатили.
   - При використанні **Cold** _Observables_:
     - Коли потрібно отримати однакові дані для кожного передплатника.
     - Коли ви хочете, щоб кожен передплатник починав отримання даних із початку.
   - Коли використовувати **Hot** _Observables_:
     - Коли дані є спільними для всіх передплатників і не потрібно їх повторної генерації.
     - Коли важливим є момент створення та початку випускання подій, незалежно від того, чи є передплатники.
2. **У чому різниця між операторами mergeMap та switchMap у RxJS? Яке застосування кожного з них може бути у ваших проектах?**

   - mergeMap і switchMap - це два оператори RxJS, які використовуються для перетворення елементів Observable на інші Observable, а також для злиття або перемикання між отриманими Observable.
   - mergeMap: Використовується для злиття результатів кількох Observable в єдиний потік. Кожен отриманий елемент перетворюється на новий Observable, і всі ці Observable зливаються в один.
   - switchMap: Використовується для перемикання на новий Observable та скасування попереднього, коли отримано новий елемент. Тільки результати останнього Observable залишаються у потоці.

3. **Як використовувати RxJS для роботи з WebSocket? Які оператори або стратегії ви використовували для обробки повідомлень через WebSocket у реальному часі?**

   - RxJS надає зручні засоби для роботи з WebSocket та обробки повідомлень у реальному часі.
   - Створення підключення до WebSocket: Використовуйте вбудований у браузер клас WebSocket для створення з'єднання. Також можна використовувати бібліотеки типу rxjs/webSocket для спрощення інтеграції.
   - Підписка на події: Використовуйте оператор multiplex для передплати певних типів подій.

4. **Які оператори RxJS ви використовували у своєму досвіді розробки? Наведіть приклад сценарію, коли використання певного оператора було особливо корисним.**

   - RxJS надає безліч операторів і вибір конкретного оператора залежить від сценарію використання. Ось кілька операторів, які часто використовуються в досвіді розробки, а також приклади сценаріїв, де вони можуть бути особливо корисними:

   - map: Перетворює кожне значення в потоці за допомогою цієї функції.
   - filter: Фільтрує значення в потоці за допомогою даної умови.
   - mergeMap: Застосовує функцію кожного значення і об'єднує результати в один потік.
   - switchMap: Переключається на новий потік під час кожного нового значення, скасовуючи попередній.
   - forkJoin: використовується для об'єднання результатів кількох Observable в один Observable

## Markup

1. **Назвіть кілька способів реалізації lazy-loading медіаресурсів на сторінці**

   - Завантаження зображень за допомогою атрибута `loading`. У HTML5, атрибут `loading` був введений для елемента `<img>`, який може приймати значення `lazy`, `eager` і `auto`. Параметр `loading = «lazy»` наказує браузеру затримувати завантаження зображення, доки його не буде видно на екрані.

   - `Intersection Observer API`. Це JavaScript API, який дозволяє відстежувати, коли елемент входить в **viewport**. Ви можете використовувати `Intersection Observer API`, щоб почати завантаження медіа-ресурсів, коли вони стають видимими.
   - Використання бібліотек та фреймворків;
   - Використовуючи JavaScript, базуючись на позиції прокрутки. Можна використовувати JavaScript, щоб перевірити положення прокрутки сторінки і почати завантаження медіа-ресурсів, коли вона наближаються до видимої області.

2. **Що таке Sass та в чому його переваги перед звичайним CSS?**

   - Sass (Syntactically Awesome Style Sheets) - є CSS препроцесором, який додає додаткові функціональні можливості до звичайного CSS. До його переваг можна віднести:

     - Змінні для зберігання значень і повторного використання.
     - Міксіни для створення блоків багаторазового стилю.
     - Вбудовані правила для кращої структури коду і читабельності.
     - Можливість використання логіки та операторів.
     - Покращена читаність і менша кількість написаного коду.

3. **Що таке міксіни в Sass та як їх використовувати?**

   - Міксіни в Sass - є блоками стилів, які можна повторно використовувати в різних місцях. Вони оголошуються через `@mixin` і викликаються через `@include`.

4. **Як можна генерувати цикли та умови в Sass за допомогою директив?**

   - Sass має `@for`, `@each` і `@if` директиви, які дозволяють створювати цикли і умови в коді. Наприклад:
   - `for $i from 1 through 5 {...}` створить цикл з 1 до 5.
   - `every $color in $colors {...}` дозволяє переглядати елементи списку.
   - `if $condition {...}` виконує код залежно від умови.

## JS

1. **Що таке замикання (closure) у JavaScript, і які переваги та недоліки воно надає у розробці? Наведіть приклади використання замикань.**

   - Замикання це функція, яка має доступ до змінних зовнішньої функції, навіть після того, як зовнішня функція завершила свою роботу.
   - Перевагами замикання є збереження стану між викликами функцій, створення приватних змінних і реалізація модульності.
   - Недоліком може бути потенційний витік пам'яті, якщо ними неправильно керувати.

2. **Як працює механізм успадкування JavaScript? Опишіть прототипне успадкування та як створити ланцюжок прототипів.**

   - В JavaScript успадкування здійснюється за допомогою прототипів. Кожен об'єкт має властивість `prototype`, яка вказує на інший об'єкт, відомий як його прототип. Якщо властивість не знайдена в об'єкті, JavaScript буде шукати його в прототипі і так далі. Ви можете створити ланцюжок прототипів, призначивши об'єкт прототипа іншому об'єкту через властивість `prototype`.

3. **Як працює `Event Loop` у JavaScript, і яким чином він обробляє події та асинхронні завдання?**

   - Event Loop - це механізм в JavaScript, який забезпечує виконання асинхронного коду. Він відстежує виконання синхронних завдань і обробляє асинхронні події і завдання, ставлячи їх в чергу на виконання. Коли стек викликів `(call stack)` порожній, `Event Loop` бере завдання з черги і виконує його.

4. **Чим відрізняється Observable від Promise? Розкажіть про послідовне та паралельне виконання асинхронних функцій.**

   - Ключова відмінність полягає в тому, що `Promise` підходить для одноразових асинхронних операцій з одним результатом, тоді як `Observable` призначений для роботи з потоками даних, які можуть генерувати кілька значень з плином часу.
   - `Promise`:
     - Являє собою єдине значення, яка буде доступне в майбутньому (**fulfilled or rejected** ).
     - Не має вбудованої можливості скасування.
     - Підтримує методи `then()` і `catch()` для обробки успішного завершення або помилки.
     - Не має вбудованої підтримки для повернення декількох значень або потоків даних.
   - `Observable`:
     - Являє собою потік даних, який може містити кілька значень.
     - Підтримує операції відписки через `unsubscribe()`.
     - Має багато операторів для маніпулювання даними, такі як `map()`, `filter()`, `merge()` та інші.
     - Використовується для реактивного програмування та для роботи з потоками даних.
   - При виконанні асинхронних функцій послідовно кожна функція запускається і чекає завершення попередньої перед запуском. При паралельному виконанні асинхронні функції виконуються одночасно, не чекаючи завершення одна одної. Вибір між ними залежить від потреб: послідовне виконання підходить для залежних операцій, а паралельне виконання підходить для незалежних, для підвищення продуктивності.

## Angular

1. **Як працює впровадження залежностей (`dependency injection`) в `Angular`?**

- Основна ідея `DI` полягає в тому, що компоненти не створюють своїх залежностей, а отримують їх ззовні. Це сприяє більш гнучкій та тестованій архітектурі програми.
- Процес роботи системи залежностей в `Angular` включає такі кроки:
  1. Реєстрація залежностей: Кожна залежність (сервіс) реєструється у певному модулі з використанням провайдера (`provider`). Це може бути компонент, сервіс, завод (`factory`) і так далі.
  2. Впровадження залежностей у конструктор (`constructor()`): Коли компонент або інший об'єкт створюється, Angular автоматично впроваджує необхідні залежності у його конструктор. Це завдяки аналізу типів в параметрах конструктора.
  3. Життєвий цикл: Angular управляє життєвим циклом залежностей. Якщо якась залежність має область видимості, наприклад "singleton", вона буде створена лише один раз і використовуватиметься повторно при кожному запиті на впровадження.

1. **Що таке резолвери (`resolvers`) у Angular і для чого вони використовуються?**

   - Резолвери - це функції, які використовуються для попереднього завантаження даних, необхідних для активації певного маршруту (`route`) у додатку перед тим, як компонент або подання буде відображено. Вони дозволяють отримати дані із сервера або виконати інші асинхронні операції перед відображенням компонента.

2. **Що таке перехоплювачі запитів (`Http Interceptor`), як вони працюють і для чого потрібні? Наведіть приклад використання.**

   - Перехоплювачі перевіряють і перетворюють `HTTP`-запити від вашої програми до сервера. Ті самі перехоплювачі можуть перевіряти та перетворювати відповіді сервера на зворотному шляху до програми. Декілька перехоплювачів утворюють прямий і зворотний ланцюжок обробників запитів/відповідей.
   - Перехоплювачі можуть виконувати безліч неявних завдань, від автентифікації до реєстрації, стандартним способом для кожного `HTTP`-запиту/відповіді.
   - Без перехоплення розробникам довелося б явно реалізовувати ці завдання за допомогою `HttpClient` виклику методу.

3. **Як реалізувати отримання даних (наприклад, конфігурацію додатка) з сервера до ініціалізації додатка?**

   - Для отримання даних, таких як конфігурація програми з сервера до ініціалізації програми в Angular, можна скористатися концепцією `APP_INITIALIZER`. Цей механізм дозволяє виконати певні дії перед ініціалізацією кореневого модуля програми.

4. **Що таке охоронці маршрутів (`route guards`), як вони працюють і для чого потрібні? Які існують методи?**

- Охоронці маршрутів є механізмами, що використовуються для управління навігацією між маршрутами в додатку. Вони дозволяють виконувати певні перевірки перед тим, як дозволити або заборонити навігацію користувача за певними маршрутами.
- Методи:
  - `canActivate`: Перевіряє, чи можна активувати маршрут. Якщо `true` повертає, навігація дозволена, якщо `false` - заборонена.
  - `canActivateChild`: Схожий на `CanActivate`, але застосовується до дочірніх маршрутів. Перевіряє, чи можна активувати дочірні маршрути.
  - `canDeactivate`: Дозволяє перевірити, чи можна залишити поточний маршрут. Якщо повертає `true`, користувачеві дозволено залишити маршрут, якщо `false` – навігація буде скасована.
  - `canMatch`: перевіряє, чи є у користувача дозвіл на доступ до маршруту.

1. Як працює механізм `Change Detection` в Angular, і що відбувається, коли змінюється стан компонентів? Які існують типи стратегій `Change Detection`?

   - Механізм Change Detection у Angular відстежує зміни у стані компонентів та оновлює уявлення за потреби. Коли змінюється стан компонента, Angular автоматично запускає процес Change Detection для визначення, які частини подання потребують оновлення.
   - Цей процес повторюється дуже ефективно завдяки механізму `Zone.js`, який дозволяє Angular відстежувати асинхронні події та надає контекст виконання для виявлення змін. Він також використовує ієрархію компонентів, що дозволяє мінімізувати область перевірки, фокусуючись лише на компонентах, що вимагають зміни.
   - У Angular існують два основні типи стратегій Change Detection: **"Default"** та **"OnPush"**. Кожна з цих стратегій надає різний спосіб визначення того, коли та як повинен запускатись механізм Change Detection.
     - Default (за замовчуванням) – це стратегія, яка запускає механізм Change Detection за будь-якої події.
     - OnPush - це більш оптимізована стратегія, яка запускає механізм Change Detection лише у випадку, якщо змінені вхідні дані компонента або якщо відбулися зміни в об'єктах, переданих компоненту за посиланням (наприклад, масиви чи об'єкти). Це дозволяє знизити кількість перевірок та покращити продуктивність програми.

2. **Як RxJS інтегрований до Angular? Які можливості надає Angular для роботи з RxJS і як ви використовували Observable у контексті розробки Angular-додатків?**

   - `RxJS` тісно інтегрований в Angular і відіграє ключову роль у обробці асинхронних подій та керуванні даними в Angular-додатках.
   - Інтеграція з HTTP-запитами: Angular використовує RxJS для обробки HTTP-запитів
   - Інтеграція з подіями форм: Angular використовує `Observable`, щоб обробляти події форм та взаємодію користувача. Наприклад, використання `FormBuilder` і методу `valueChanges()`
   - Використання `AsyncPipe`: Angular надає AsyncPipe, який полегшує роботу з асинхронними даними у шаблонах
   - Інтеграція з роутингом: Angular використовує RxJS для роботи з роутингом. Наприклад, метод `router.events` повертає `Observable`, дозволяючи відслідковувати зміни у маршрутах

3. **Які зміни відбулися в останніх версіях Angular?**

   - Standalone Components
   - Directive composition API
   - Signals - це система, яка детально відстежує, як і де ваш стан використовується у додатку, дозволяючи платформі оптимізувати оновлення рендерингу.
   - Новий синтаксис шаблонів
   - Ліниве завантаження компонентів (`lazy-loading`)
   - Гібридний рендеринг на стороні сервера (`SSR`)
   - Нові перехоплювачі життєвого циклу компонента `afterRender` та `afterNextRender`
